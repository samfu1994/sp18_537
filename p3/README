Overview: 
    There are 2 parts in this project.
        1   The implementation of parallel zip.
        2   The null pointer and memory protection mechanism in xv6.

Part1(PZIP)
    I assume that the number of threads in the machines is significantly smaller than the number of bytes in each single file to be compressed. 
    Consequently, process file by file sequentially and use the parallelism inside the processing of each file.
    First get the number of threads available in the machine, then divide the current file equally by the thread number. Finally just concat each piece of the file and we have the result.


Part2(xv6)
    A. NULL Pointer
        Since xv6 has provided that if we access an address who has not been allocated, it will trap and kill the process(which what we expect). 
        All we need to do is to make sure the first page is never allocated and then it is an invalid address for 0x0. Thus we only need to change the first bit to be allocated from 0 to 4096.
        Additionally, check the address in arg parsing functions to make sure there is no NULL pointer deference, otherwise just return invalid code.

        To make sure the child process generated by fork shares a same property, in function copynum(), start copying from 4096 instead of 0.
        Finally, change the entry point from 0 to 4096 to make sure we have a valid entry point for user.

    B. Memory Protection
        Added two system calls, mprotect and munprotect.
        Since the page table entry stores the protection bits in its least significant bits, we only need to change the second least significant bit to change its writable property.
        Each time fetch the address of the page table entry by the virtual address, then change the corresponding bits(contents stored in the entry of lowest level page table) mentioned above can do the job.


